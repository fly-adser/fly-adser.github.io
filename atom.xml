<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fly Adser</title>
  
  <subtitle>一个广告策略算法工程师的学习笔记</subtitle>
  <link href="http://fly-adser.top/atom.xml" rel="self"/>
  
  <link href="http://fly-adser.top/"/>
  <updated>2022-02-26T14:32:10.573Z</updated>
  <id>http://fly-adser.top/</id>
  
  <author>
    <name>Fly Adser</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>238.除自身以外数组的乘积</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode238/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode238/</id>
    <published>2022-02-26T14:28:55.000Z</published>
    <updated>2022-02-26T14:32:10.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。<a href="https://leetcode-cn.com/problems/product-of-array-except-self/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nLen  = <span class="built_in">len</span>(nums)</span><br><span class="line">        res   = [<span class="number">1</span>] * nLen </span><br><span class="line">        res[nLen-<span class="number">1</span>] = nums[nLen-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(nLen-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            res[i] = nums[i] * res[i+<span class="number">1</span>] </span><br><span class="line">        </span><br><span class="line">        leftProduct = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, nLen-<span class="number">1</span>):</span><br><span class="line">            res[i]        = leftProduct * res[i+<span class="number">1</span>]</span><br><span class="line">            leftProduct  *= nums[i] </span><br><span class="line">        res[-<span class="number">1</span>] = leftProduct </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。&lt;a href=&quot;https://leetcode-cn.com/problems/product-of-array-except-self/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="http://fly-adser.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>236.二叉树的最近公共祖先</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode236-1/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode236-1/</id>
    <published>2022-02-26T14:26:26.000Z</published>
    <updated>2022-02-26T14:28:31.992Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root, p, q</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line"></span><br><span class="line">        left  = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root==p <span class="keyword">or</span> root==q) <span class="keyword">and</span> (left <span class="keyword">or</span> right): <span class="keyword">return</span> root </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right: <span class="keyword">return</span> root </span><br><span class="line">        <span class="keyword">if</span> left: <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right: <span class="keyword">return</span> right </span><br><span class="line">        <span class="keyword">if</span> root==p <span class="keyword">or</span> root==q: <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。&lt;a href=&quot;https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="二叉树" scheme="http://fly-adser.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>234.回文链表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode234/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode234/</id>
    <published>2022-02-26T14:23:10.000Z</published>
    <updated>2022-02-26T14:25:41.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。<a href="https://leetcode-cn.com/problems/palindrome-linked-list/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line">        left = right = head </span><br><span class="line">        nLen = <span class="number">1</span> </span><br><span class="line">        <span class="keyword">while</span> right.<span class="built_in">next</span>:</span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">            nLen += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        diff  = nLen // <span class="number">2</span> + nLen % <span class="number">2</span> </span><br><span class="line">        pre   = <span class="literal">None</span></span><br><span class="line">        right = head </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(diff):</span><br><span class="line">            pre   = right </span><br><span class="line">            right = right.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        pre.<span class="built_in">next</span> = <span class="literal">None</span> </span><br><span class="line">        pre, cur = <span class="literal">None</span>, right</span><br><span class="line">        <span class="keyword">if</span> cur: nxt = cur.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.<span class="built_in">next</span> = pre </span><br><span class="line">            pre, cur = cur, nxt </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">break</span> </span><br><span class="line">            nxt      = cur.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        right = pre </span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val!=right.val: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            left  = left.<span class="built_in">next</span> </span><br><span class="line">            right = right.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。&lt;a href=&quot;https://leetcode-cn.com/problems/palindrome-linked-list/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>226.翻转二叉树</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode226/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode226/</id>
    <published>2022-02-26T14:13:58.000Z</published>
    <updated>2022-02-26T14:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。<a href="https://leetcode-cn.com/problems/invert-binary-tree/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> (root.left <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="literal">None</span>): <span class="keyword">return</span> root </span><br><span class="line"></span><br><span class="line">        root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。&lt;a href=&quot;https://leetcode-cn.com/problems/invert-binary-tree/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="二叉树" scheme="http://fly-adser.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>221.最大正方形</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode221/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode221/</id>
    <published>2022-02-26T14:11:43.000Z</published>
    <updated>2022-02-26T14:13:27.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。<a href="https://leetcode-cn.com/problems/maximal-square/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maximalSquare</span>(<span class="params">self, matrix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type matrix: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span>]*cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        maxArea = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols): </span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][i]==<span class="string">&#x27;1&#x27;</span>: </span><br><span class="line">                maxArea  = <span class="number">1</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows): </span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>: </span><br><span class="line">                maxArea  = <span class="number">1</span></span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]), dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span> </span><br><span class="line">                    maxArea  = <span class="built_in">max</span>(maxArea, dp[i][j]*dp[i][j])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">0</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxArea</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;在一个由 ‘0’ 和 ‘1’ 组成的二维矩阵内，找到只包含 ‘1’ 的最大正方形，并返回其面积。&lt;a href=&quot;https://leetcode-cn.com/problems/maximal-square/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>215.数组中的第K个最大元素</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode215/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode215/</id>
    <published>2022-02-26T14:09:05.000Z</published>
    <updated>2022-02-26T14:11:33.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span>(<span class="params">self, nums, k</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nLen==<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        self.quickSort(nums, <span class="number">0</span>, nLen-<span class="number">1</span>, k)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[k-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickSort</span>(<span class="params">self, nums, left, right, k</span>):</span></span><br><span class="line">        index = self.partition(nums, left, right)</span><br><span class="line">        <span class="keyword">if</span> left&gt;=right <span class="keyword">or</span> index==k-<span class="number">1</span>: <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index&lt;k-<span class="number">1</span>:</span><br><span class="line">            self.quickSort(nums, index+<span class="number">1</span>, right, k)</span><br><span class="line">        </span><br><span class="line">        self.quickSort(nums, left, index-<span class="number">1</span>, k)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span>(<span class="params">self, nums, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left&gt;=right: <span class="keyword">return</span> left </span><br><span class="line"></span><br><span class="line">        index = right </span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            <span class="keyword">if</span> nums[right]&lt;nums[left]:</span><br><span class="line">                nums[right], nums[index] = nums[index], nums[right]</span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">                index -= <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right -= <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left&lt;index:</span><br><span class="line">            nums[left], nums[index] = nums[index], nums[left]</span><br><span class="line">            <span class="keyword">return</span> index </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。&lt;a href=&quot;https://leetcode-cn.com/problems/kth-largest-element-in-an-array/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="排序" scheme="http://fly-adser.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>208.实现Trie(前缀树)</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode208/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode208/</id>
    <published>2022-02-26T14:05:53.000Z</published>
    <updated>2022-02-26T14:08:11.239Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。<a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.children = [<span class="literal">None</span>] * <span class="number">26</span> </span><br><span class="line">        self.isEnd    = <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPrefix</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        node = self</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">            ch = <span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>) </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.children[ch]: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">            node = node.children[ch]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> node </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self </span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> word:</span><br><span class="line">            ch = <span class="built_in">ord</span>(s) - <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.children[ch]:</span><br><span class="line">                node.children[ch] = Trie()</span><br><span class="line">            node = node.children[ch]  </span><br><span class="line">        </span><br><span class="line">        node.isEnd = <span class="literal">True</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, word</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.findPrefix(word)</span><br><span class="line">        <span class="keyword">if</span> node: <span class="keyword">return</span> node.isEnd </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span>(<span class="params">self, prefix</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type prefix: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        node = self.findPrefix(prefix)</span><br><span class="line">        <span class="keyword">if</span> node: <span class="keyword">return</span> <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。&lt;a href=&quot;https://leetcode-cn.com/problems/implement-trie-prefix-tree/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>207.课程表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode207/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode207/</id>
    <published>2022-02-26T14:01:23.000Z</published>
    <updated>2022-02-26T14:06:02.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi </p><ul><li>例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。<a href="https://leetcode-cn.com/problems/course-schedule/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span>(<span class="params">self, numCourses, prerequisites</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        indegrees = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line">        adjaency  = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(numCourses)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> cur, pre <span class="keyword">in</span> prerequisites:</span><br><span class="line">            indegrees[cur] += <span class="number">1</span> </span><br><span class="line">            adjaency[pre].append(cur)</span><br><span class="line">        </span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numCourses):</span><br><span class="line">            <span class="keyword">if</span> indegrees[i]==<span class="number">0</span>: queue.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            course = queue.pop()</span><br><span class="line">            numCourses -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> cur <span class="keyword">in</span> adjaency[course]:</span><br><span class="line">                indegrees[cur] -= <span class="number">1</span> </span><br><span class="line">                <span class="keyword">if</span> indegrees[cur]==<span class="number">0</span>: queue.append(cur)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> numCourses</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。&lt;a href=&quot;https://leetcode-cn.com/problems/course-schedule/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
    <category term="拓扑排序" scheme="http://fly-adser.top/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>206.翻转链表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode206/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode206/</id>
    <published>2022-02-26T13:59:27.000Z</published>
    <updated>2022-02-26T14:01:08.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。<a href="https://leetcode-cn.com/problems/reverse-linked-list/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> head </span><br><span class="line">        pre, cur = head, head.<span class="built_in">next</span></span><br><span class="line">        nxt      = cur.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            cur.<span class="built_in">next</span> = pre </span><br><span class="line">            pre      = cur </span><br><span class="line">            cur      = nxt </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> cur: <span class="keyword">return</span> pre </span><br><span class="line">            nxt      = cur.<span class="built_in">next</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pre</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>200.岛屿数量</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode200/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode200/</id>
    <published>2022-02-26T13:56:46.000Z</published>
    <updated>2022-02-26T13:59:08.142Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。<a href="https://leetcode-cn.com/problems/number-of-islands/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span>(<span class="params">self, grid</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        vaild      = [[<span class="literal">False</span>]*cols <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(rows)]</span><br><span class="line">        countLands = <span class="number">0</span></span><br><span class="line">        orients    = [[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">recur</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;0&#x27;</span>: <span class="keyword">return</span> </span><br><span class="line">            vaild[i][j] = <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> orient <span class="keyword">in</span> orients:</span><br><span class="line">                row, col = i + orient[<span class="number">0</span>], j + orient[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> inArea(row, col) <span class="keyword">and</span> <span class="keyword">not</span> vaild[row][col]: recur(row, col)</span><br><span class="line">                row, col = i, j </span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inArea</span>(<span class="params">i, j</span>):</span></span><br><span class="line">            <span class="keyword">return</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> i&lt;rows <span class="keyword">and</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> j&lt;cols </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, cols):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> <span class="keyword">not</span> vaild[i][j]: </span><br><span class="line">                    recur(i, j)</span><br><span class="line">                    countLands += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> countLands</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-islands/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="搜索与回溯算法" scheme="http://fly-adser.top/tags/%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>198.打家劫舍</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode198/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode198/</id>
    <published>2022-02-26T13:54:04.000Z</published>
    <updated>2022-02-26T13:56:49.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。<a href="https://leetcode-cn.com/problems/house-robber/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nLen&lt;=<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> nLen&lt;=<span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * nLen </span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = nums[<span class="number">0</span>], <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]) </span><br><span class="line">        maxRes = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, nLen):</span><br><span class="line">            maxPast = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, i-<span class="number">1</span>):</span><br><span class="line">                maxPast = <span class="built_in">max</span>(maxPast, dp[j])</span><br><span class="line">            </span><br><span class="line">            dp[i] = maxPast + nums[i] </span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes, dp[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxRes</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。&lt;a href=&quot;https://leetcode-cn.com/problems/house-robber/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>169.多数元素</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode169-1/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode169-1/</id>
    <published>2022-02-26T13:51:21.000Z</published>
    <updated>2022-02-26T13:53:56.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。<a href="https://leetcode-cn.com/problems/majority-element/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nLen&lt;=<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        digit = nums[<span class="number">0</span>]</span><br><span class="line">        count = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nLen):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==digit:</span><br><span class="line">                count += <span class="number">1</span> </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                count -= <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> count&lt;<span class="number">0</span>:</span><br><span class="line">                count = <span class="number">1</span> </span><br><span class="line">                digit = nums[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> digit</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。&lt;a href=&quot;https://leetcode-cn.com/problems/majority-element/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="数组" scheme="http://fly-adser.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>160.相交链表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode160-1/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode160-1/</id>
    <published>2022-02-26T13:48:55.000Z</published>
    <updated>2022-02-26T13:51:25.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span>(<span class="params">self, headA, headB</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        aLen, bLen = <span class="number">0</span>, <span class="number">0</span> </span><br><span class="line">        nodeA, nodeB = headA, headB </span><br><span class="line">        <span class="keyword">while</span> nodeA:</span><br><span class="line">            aLen += <span class="number">1</span> </span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span> </span><br><span class="line">        <span class="keyword">while</span> nodeB:</span><br><span class="line">            bLen += <span class="number">1</span> </span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        diffLen = <span class="built_in">abs</span>(aLen - bLen)</span><br><span class="line">        <span class="keyword">if</span> aLen&gt;bLen:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(diffLen):</span><br><span class="line">                headA = headA.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> headA: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(diffLen):</span><br><span class="line">                headB = headB.<span class="built_in">next</span> </span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> headB: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> headA <span class="keyword">and</span> headB:</span><br><span class="line">            <span class="keyword">if</span> headA==headB: <span class="keyword">return</span> headA </span><br><span class="line">            headA = headA.<span class="built_in">next</span> </span><br><span class="line">            headB = headB.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>152.乘积最大子数组</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode152/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode152/</id>
    <published>2022-02-26T13:45:21.000Z</published>
    <updated>2022-02-26T13:49:00.540Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<a href="https://leetcode-cn.com/problems/maximum-product-subarray/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProduct</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        nLen = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nLen&lt;=<span class="number">1</span>: <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        dpA, dpB = [<span class="number">0</span>] * nLen, [<span class="number">0</span>] * nLen </span><br><span class="line">        dpA[<span class="number">0</span>], dpB[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        maxRes = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, nLen):</span><br><span class="line">            dpA[i] = <span class="built_in">max</span>(<span class="built_in">max</span>(dpA[i-<span class="number">1</span>]*nums[i], dpB[i-<span class="number">1</span>]*nums[i]), nums[i])</span><br><span class="line">            dpB[i] = <span class="built_in">min</span>(<span class="built_in">min</span>(dpA[i-<span class="number">1</span>]*nums[i], dpB[i-<span class="number">1</span>]*nums[i]), nums[i])</span><br><span class="line">            maxRes = <span class="built_in">max</span>(maxRes, dpA[i])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxRes</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。&lt;a href=&quot;https://leetcode-cn.com/problems/maximum-product-subarray/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>148.排序链表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode148/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode148/</id>
    <published>2022-02-26T13:43:01.000Z</published>
    <updated>2022-02-26T13:44:47.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。<a href="https://leetcode-cn.com/problems/sort-list/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortList</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span> </span><br><span class="line">        node, nLen = head, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">             nLen += <span class="number">1</span> </span><br><span class="line">             node  = node.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> nLen&lt;=<span class="number">0</span>: <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">return</span> self.mergeSort(head, nLen)</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span>(<span class="params">self, node, nLen</span>):</span></span><br><span class="line">        <span class="keyword">if</span> nLen==<span class="number">1</span>: <span class="keyword">return</span> node </span><br><span class="line"></span><br><span class="line">        mid   = nLen // <span class="number">2</span></span><br><span class="line">        leftList, index = node, node </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, mid):</span><br><span class="line">            index = index.<span class="built_in">next</span> </span><br><span class="line">        preNode      = index </span><br><span class="line">        rightList    = index.<span class="built_in">next</span> </span><br><span class="line">        preNode.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        left  = self.mergeSort(leftList, mid)</span><br><span class="line">        right = self.mergeSort(rightList, nLen-mid)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.merge(left, right)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> right: <span class="keyword">return</span> left </span><br><span class="line"></span><br><span class="line">        head = ListNode(-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">            head.<span class="built_in">next</span> = left</span><br><span class="line">            left  = left.<span class="built_in">next</span>  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            head.<span class="built_in">next</span> = right</span><br><span class="line">            right = right.<span class="built_in">next</span>  </span><br><span class="line">        </span><br><span class="line">        index = head.<span class="built_in">next</span>  </span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;=right.val:</span><br><span class="line">                index.<span class="built_in">next</span> = left </span><br><span class="line">                left  = left.<span class="built_in">next</span> </span><br><span class="line">                index = index.<span class="built_in">next</span> </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index.<span class="built_in">next</span> = right </span><br><span class="line">                right = right.<span class="built_in">next</span> </span><br><span class="line">                index = index.<span class="built_in">next</span>  </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left: index.<span class="built_in">next</span>  = left </span><br><span class="line">        <span class="keyword">if</span> right: index.<span class="built_in">next</span> = right </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="分治算法" scheme="http://fly-adser.top/tags/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>146.LRU缓存</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode146/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode146/</id>
    <published>2022-02-26T13:39:02.000Z</published>
    <updated>2022-02-26T13:42:57.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。<a href="https://leetcode-cn.com/problems/lru-cache/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedNode</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, key, value, pre=<span class="literal">None</span>, nxt=<span class="literal">None</span></span>):</span></span><br><span class="line">        self.key   = key </span><br><span class="line">        self.value = value </span><br><span class="line">        self.pre   = pre </span><br><span class="line">        self.<span class="built_in">next</span>  = nxt </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, capacity</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type capacity: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.cache    = &#123;&#125;</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.size     = <span class="number">0</span></span><br><span class="line">        self.head     = LinkedNode(-<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">        self.tail     = LinkedNode(-<span class="number">1</span>, -<span class="number">1</span>, self.head)</span><br><span class="line">        self.head.<span class="built_in">next</span> = self.tail</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        pre = node.pre</span><br><span class="line">        nxt = node.<span class="built_in">next</span> </span><br><span class="line"></span><br><span class="line">        pre.<span class="built_in">next</span>, nxt.pre = nxt, pre</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNode</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        nxt = self.head.<span class="built_in">next</span> </span><br><span class="line">        self.head.<span class="built_in">next</span> = node </span><br><span class="line">        node.pre       = self.head </span><br><span class="line">        nxt.pre        = node </span><br><span class="line">        node.<span class="built_in">next</span>      = nxt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache: <span class="keyword">return</span> -<span class="number">1</span> </span><br><span class="line">        node = self.cache[key]</span><br><span class="line">        self.delNode(node)</span><br><span class="line">        self.addNode(node)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type key: int</span></span><br><span class="line"><span class="string">        :type value: int</span></span><br><span class="line"><span class="string">        :rtype: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.cache:</span><br><span class="line">            node = self.cache[key]</span><br><span class="line">            node.value = value </span><br><span class="line">            self.delNode(node)</span><br><span class="line">            self.addNode(node) </span><br><span class="line">            <span class="keyword">return</span>  </span><br><span class="line">        </span><br><span class="line">        node = LinkedNode(key, value)</span><br><span class="line">        self.addNode(node)</span><br><span class="line">        self.cache[key] = node</span><br><span class="line">        self.size += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">if</span> self.size&gt;self.capacity:</span><br><span class="line">            delKey = self.tail.pre.key </span><br><span class="line">            <span class="keyword">del</span> self.cache[delKey]</span><br><span class="line">            self.delNode(self.tail.pre)</span><br><span class="line">            self.size -= <span class="number">1</span> </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。&lt;a href=&quot;https://leetcode-cn.com/problems/lru-cache/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="栈与队列" scheme="http://fly-adser.top/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>142.环形链表II</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode142/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode142/</id>
    <published>2022-02-26T13:35:36.000Z</published>
    <updated>2022-02-26T13:39:51.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。<a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> head.<span class="built_in">next</span> <span class="keyword">is</span> <span class="literal">None</span>: <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">if</span> head.<span class="built_in">next</span> == head: <span class="keyword">return</span> head   </span><br><span class="line"></span><br><span class="line">        fast, slow = head, head </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span> </span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> fast==slow: <span class="keyword">break</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> fast!=slow:</span><br><span class="line">            fast = fast.<span class="built_in">next</span> </span><br><span class="line">            slow = slow.<span class="built_in">next</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle-ii/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>141.环形链表</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode141/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode141/</id>
    <published>2022-02-26T13:31:05.000Z</published>
    <updated>2022-02-26T13:35:30.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个链表的头节点 head ，判断链表中是否有环。<a href="https://leetcode-cn.com/problems/linked-list-cycle/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span>(<span class="params">self, head</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line"></span><br><span class="line">        slow, fast = head, head </span><br><span class="line">        <span class="keyword">while</span> fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>: <span class="keyword">return</span> <span class="literal">False</span> </span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span> </span><br><span class="line">            <span class="keyword">if</span> fast==slow: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个链表的头节点 head ，判断链表中是否有环。&lt;a href=&quot;https://leetcode-cn.com/problems/linked-list-cycle/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="链表" scheme="http://fly-adser.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>139.单次拆分</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode139/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode139/</id>
    <published>2022-02-26T13:28:49.000Z</published>
    <updated>2022-02-26T13:30:41.211Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。<a href="https://leetcode-cn.com/problems/word-break/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span>(<span class="params">self, s, wordDict</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :type wordDict: List[str]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        sLen   = <span class="built_in">len</span>(s)</span><br><span class="line">        dp     = [<span class="literal">False</span>] * (sLen + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>]  = <span class="literal">True</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(sLen):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, sLen+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> dp[i] <span class="keyword">and</span> s[i:j] <span class="keyword">in</span> wordDict: dp[j] = <span class="literal">True</span> </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。&lt;a href=&quot;https://leetcode-cn.com/problems/word-break/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
  <entry>
    <title>128.最长连续序列</title>
    <link href="http://fly-adser.top/2022/02/26/leetcode128/"/>
    <id>http://fly-adser.top/2022/02/26/leetcode128/</id>
    <published>2022-02-26T13:22:26.000Z</published>
    <updated>2022-02-26T13:28:35.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。<a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">题目链接</a><br><span id="more"></span></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span>(<span class="params">self, nums</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;=<span class="number">1</span>: <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br><span class="line">        nums_set       = <span class="built_in">set</span>(nums)</span><br><span class="line">        longestSquence = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> (nums[i]-<span class="number">1</span>) <span class="keyword">not</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                cur      = nums[i]</span><br><span class="line">                sequence = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> cur <span class="keyword">in</span> nums_set:</span><br><span class="line">                    sequence += <span class="number">1</span></span><br><span class="line">                    cur      += <span class="number">1</span> </span><br><span class="line"></span><br><span class="line">                longestSquence = <span class="built_in">max</span>(longestSquence, sequence)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> longestSquence</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。&lt;a href=&quot;https://leetcode-cn.com/problems/longest-consecutive-sequence/&quot;&gt;题目链接&lt;/a&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://fly-adser.top/tags/LeetCode/"/>
    
    <category term="动态规划" scheme="http://fly-adser.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="Hot100" scheme="http://fly-adser.top/tags/Hot100/"/>
    
  </entry>
  
</feed>
